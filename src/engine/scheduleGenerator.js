import { formatDateKey, daysBetween } from '../utils/dateUtils';
import { calculateUrgency } from '../utils/urgencyCalculator';

export function generateStudySchedule(tasks, subjects, config, existingBlocks = []) {
  const blocks = [];
  const today = new Date();

  // Build priority queue of study items
  const studyItems = [];

  // Pending tasks with deadlines
  const pendingTasks = tasks
    .filter(t => t.status !== 'done' && t.deadline)
    .map(t => ({
      type: 'task',
      id: t.id,
      title: t.title,
      subject: t.subject,
      deadline: new Date(t.deadline),
      estimatedMinutes: t.estimatedMinutes || config.blockDurationMinutes,
      urgency: calculateUrgency(t.deadline),
      priority: { high: 30, medium: 15, low: 5 }[t.priority] || 15,
    }))
    .sort((a, b) => (b.urgency + b.priority) - (a.urgency + a.priority));

  studyItems.push(...pendingTasks);

  // Pending tasks without deadlines
  const noDeadlineTasks = tasks
    .filter(t => t.status !== 'done' && !t.deadline)
    .map(t => ({
      type: 'task',
      id: t.id,
      title: t.title,
      subject: t.subject,
      deadline: null,
      estimatedMinutes: t.estimatedMinutes || config.blockDurationMinutes,
      urgency: 10,
      priority: { high: 30, medium: 15, low: 5 }[t.priority] || 15,
    }));

  // Weak topics (confidence <= 2)
  const weakTopics = [];
  for (const subject of subjects) {
    for (const topic of subject.topics) {
      if (topic.confidence <= 2) {
        const staleness = topic.lastReviewed ? daysBetween(new Date(topic.lastReviewed), today) : 30;
        weakTopics.push({
          type: 'revision',
          id: topic.id,
          title: `${subject.name}: ${topic.name}`,
          subjectId: subject.id,
          topicId: topic.id,
          estimatedMinutes: config.blockDurationMinutes,
          urgency: (3 - topic.confidence) * 25 + staleness * 2,
          priority: 20,
        });
      }
    }
  }
  weakTopics.sort((a, b) => b.urgency - a.urgency);
  studyItems.push(...weakTopics);

  // Medium confidence topics
  for (const subject of subjects) {
    for (const topic of subject.topics) {
      if (topic.confidence === 3) {
        studyItems.push({
          type: 'revision',
          id: topic.id,
          title: `${subject.name}: ${topic.name} (Review)`,
          subjectId: subject.id,
          topicId: topic.id,
          estimatedMinutes: config.blockDurationMinutes,
          urgency: 10,
          priority: 10,
        });
      }
    }
  }

  studyItems.push(...noDeadlineTasks);

  // Generate available time slots
  const availableSlots = [];
  for (let dayOffset = 0; dayOffset < 7; dayOffset++) {
    const date = new Date(today);
    date.setDate(today.getDate() + dayOffset);

    const dayName = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'][date.getDay()];
    if (!config.preferredDays.includes(dayName)) continue;

    const dateStr = formatDateKey(date);
    let currentMinutes = config.studyStartHour * 60;
    const endMinutes = config.studyEndHour * 60;
    let blocksForDay = 0;

    while (currentMinutes + config.blockDurationMinutes <= endMinutes && blocksForDay < config.maxBlocksPerDay) {
      const startH = String(Math.floor(currentMinutes / 60)).padStart(2, '0');
      const startM = String(currentMinutes % 60).padStart(2, '0');
      const endMin = currentMinutes + config.blockDurationMinutes;
      const endH = String(Math.floor(endMin / 60)).padStart(2, '0');
      const endMn = String(endMin % 60).padStart(2, '0');
      const startTime = `${startH}:${startM}`;
      const endTime = `${endH}:${endMn}`;

      const hasConflict = existingBlocks.some(b =>
        b.day === dateStr && timesOverlap(b.startTime, b.endTime, startTime, endTime)
      );

      if (!hasConflict) {
        availableSlots.push({ day: dateStr, startTime, endTime });
      }

      currentMinutes += config.blockDurationMinutes + config.breakDurationMinutes;
      blocksForDay++;
    }
  }

  // Assign items to slots
  let slotIndex = 0;
  const assignedIds = new Set();

  for (const item of studyItems) {
    if (slotIndex >= availableSlots.length) break;
    if (assignedIds.has(item.id)) continue;

    let slot;
    if (item.deadline) {
      const deadlineKey = formatDateKey(item.deadline);
      slot = availableSlots.find((s, i) => i >= slotIndex && s.day <= deadlineKey);
    }
    if (!slot) slot = availableSlots[slotIndex];

    blocks.push({
      id: crypto.randomUUID(),
      title: item.title,
      type: item.type,
      subjectId: item.subjectId || null,
      topicId: item.topicId || null,
      taskId: item.type === 'task' ? item.id : null,
      day: slot.day,
      startTime: slot.startTime,
      endTime: slot.endTime,
      isAutoGenerated: true,
      completed: false,
    });

    assignedIds.add(item.id);
    slotIndex = availableSlots.indexOf(slot) + 1;
  }

  return blocks;
}

function timesOverlap(start1, end1, start2, end2) {
  return start1 < end2 && start2 < end1;
}
